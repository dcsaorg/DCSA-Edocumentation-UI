/**
 * DCSA OpenAPI specification for Booking v2 - Beta 1
 * API specification issued by DCSA.org.  For explanation to specific values or objects please refer to the *** [Information Model v2022.1]() *** Will be updated soon ***. This API does not define the business rules regarding what is allowed to update at what time. For this the [BKG IFS]() *** Will be updated soon *** should be consulted.  All other documents related to the Booking publication can be found [here](https://knowledge.dcsa.org/s/publication?publicationId=a0r7T000000L8mmQAC)  It is possible to use this API as a standalone API. In order to do so it is necessary to use the poll-endPoint - /v2/events  in order to poll event information.  It is recomended to implement the [DCSA Documentation Event Hub](https://app.swaggerhub.com/apis/dcsaorg/DOCUMENTATION_EVENT_HUB) in order to use the push model. Here events are pushed as they occur.  For a changelog please click [here](https://github.com/dcsaorg/DCSA-OpenAPI/tree/master/bkg/v2#v200B1). Please also [create a GitHub issue](https://github.com/dcsaorg/DCSA-OpenAPI/issues/new) if you have any questions/comments. 
 *
 * OpenAPI spec version: 2.0.0-Beta-1
 * Contact: info@dcsa.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BookingDocumentTypeCode } from '../model/bookingDocumentTypeCode';
import { BookingShipmentEventTypeCode } from '../model/bookingShipmentEventTypeCode';
import { DocumentReference } from '../model/documentReference';
import { EquipmentReference } from '../model/equipmentReference';
import { EventCreatedDateTime } from '../model/eventCreatedDateTime';
import { EventDateTime } from '../model/eventDateTime';
import { ShipmentEvent } from '../model/shipmentEvent';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class BookingEventsService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get Shipment events
     * Retrieves **booking related** Shipment events. The default sort order is by &#x60;eventCreatedDateTime&#x60; in descending order (&#x60;DESC&#x60;) 
     * @param shipmentEventTypeCode The status of the document in the booking process to filter by. Possible values are - RECE (Received) - PENU (Pending Update) - PENC (Pending Confirmation) - CONF (Confirmed) - REJE (Rejected) - CANC (Cancelled) - CMPL (Completed)  It is possible to select multiple values by comma &#x60;,&#x60; separating them. For multiple values the OR-operator is used. For example _shipmentEventTypeCode&#x3D;RECE,CONF_  Matches **both** Received (&#x60;RECE&#x60;) and Confirmed (&#x60;CONF&#x60;) &#x60;ShipmentEvents&#x60;.  More details can be found on &lt;a href&#x3D;\&quot;https://github.com/dcsaorg/DCSA-Information-Model/blob/master/datamodel/referencedata.d/shipmenteventtypecodes.csv\&quot;&gt;GitHub&lt;/a&gt;. Be aware that the list provided here is a subset of the possible values. 
     * @param documentTypeCode The &#x60;documentTypeCode&#x60; to filter by. Possible values are - CBR (Carrier Booking Request Reference) - BKG (Booking)  It is possible to select multiple values by comma &#x60;,&#x60; separating them. For multiple values the OR-operator is used. For example _documentTypeCode&#x3D;CBR,BKG_ Matches **both** &#x60;ShipmentEvents&#x60; related to Booking Requests (&#x60;CBR&#x60;) and Confirmed Bookings (&#x60;BKG&#x60;).  More details can be found on &lt;a href&#x3D;\&quot;https://github.com/dcsaorg/DCSA-Information-Model/blob/master/datamodel/referencedata.d/documenttypecodes.csv\&quot;&gt;GitHub&lt;/a&gt;. Be aware that the list provided here is a subset of the possible values.         
     * @param documentReference Filter on the &#x60;documentReference&#x60;. The &#x60;documentReference&#x60; can refer to any document - to qualify the type &#x60;documentTypeCode&#x60; should also be specified. Please be aware that &#x60;documentReference&#x60; by itself is not unique and may match different &#x27;types&#x27; of documents  Specifying this filter will only return &#x60;ShipmentEvents&#x60; related to this particular &#x60;documentReference&#x60;. 
     * @param equipmentReference Will filter by the unique identifier for the equipment, which should follow the BIC ISO Container Identification Number where possible.  Specifying this filter will only return events related to this particular &#x60;equipmentReference&#x60; 
     * @param eventCreatedDateTime Limit the result based on the creating date of the event. It is possible to use operators on this query parameter. This is done by adding a colon (&#x60;:&#x60;) followed by an operator at the end of the queryParameterName (before the equal (&#x60;&#x3D;&#x60;))      eventCreatedDateTime:gte&#x3D;2021-04-01T14:12:56+01:00  would result in all events created &amp;#8805; 2021-04-01T14&amp;#58;12&amp;#58;56+01&amp;#58;00  The following operators are supported - &#x60;:gte&#x60; (&amp;#8805; Greater than or equal) - &#x60;:gt&#x60; (&amp;#62; Greater than) - &#x60;:lte&#x60; (&amp;#8804; Less than or equal) - &#x60;:lt&#x60; (&amp;#60; Less than) - &#x60;:eq&#x60; (&amp;#61; Equal to)  If no operator is provided, a **strictly equal** is used (this is equivalent to &#x60;:eq&#x60; operator). 
     * @param eventDateTime Limit the result based on when the event will happen or has happened. It is possible to use operators on this query parameter. This is done by adding a colon (&#x60;:&#x60;) followed by an operator at the end of the queryParameterName (before the equal (&#x60;&#x3D;&#x60;))      eventDateTime:gte&#x3D;2021-04-01T14:12:56+01:00  would result in all events happened and will happen &amp;#8805; 2021-04-01T14&amp;#58;12&amp;#58;56+01&amp;#58;00  The following operators are supported - &#x60;:gte&#x60; (&amp;#8805; Greater than or equal) - &#x60;:gt&#x60; (&amp;#62; Greater than) - &#x60;:lte&#x60; (&amp;#8804; Less than or equal) - &#x60;:lt&#x60; (&amp;#60; Less than) - &#x60;:eq&#x60; (&amp;#61; Equal to)  If no operator is provided, a **strictly equal** is used (this is equivalent to &#x60;:eq&#x60; operator). 
     * @param limit Maximum number of items to return. 
     * @param sort A &#x60;,&#x60; (comma) separated list of field names to define the sort order. Field names should be suffixed by a &#x60;:&#x60; (colon) followed by either the keyword &#x60;ASC&#x60; (for ascending order) or &#x60;DESC&#x60; (for descening order) to specify direction. &#x60;:ASC&#x60; may be omitted, in which case ascending order will be used. 
     * @param aPIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: DocumentReference, equipmentReference?: EquipmentReference, eventCreatedDateTime?: EventCreatedDateTime, eventDateTime?: EventDateTime, limit?: number, sort?: string, aPIVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ShipmentEvent>>;
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: DocumentReference, equipmentReference?: EquipmentReference, eventCreatedDateTime?: EventCreatedDateTime, eventDateTime?: EventDateTime, limit?: number, sort?: string, aPIVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShipmentEvent>>>;
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: DocumentReference, equipmentReference?: EquipmentReference, eventCreatedDateTime?: EventCreatedDateTime, eventDateTime?: EventDateTime, limit?: number, sort?: string, aPIVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShipmentEvent>>>;
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: DocumentReference, equipmentReference?: EquipmentReference, eventCreatedDateTime?: EventCreatedDateTime, eventDateTime?: EventDateTime, limit?: number, sort?: string, aPIVersion?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (shipmentEventTypeCode) {
            queryParameters = queryParameters.set('shipmentEventTypeCode', shipmentEventTypeCode.join(COLLECTION_FORMATS['csv']));
        }
        if (documentTypeCode) {
            queryParameters = queryParameters.set('documentTypeCode', documentTypeCode.join(COLLECTION_FORMATS['csv']));
        }
        if (documentReference !== undefined && documentReference !== null) {
            queryParameters = queryParameters.set('documentReference', <any>documentReference);
        }
        if (equipmentReference !== undefined && equipmentReference !== null) {
            queryParameters = queryParameters.set('equipmentReference', <any>equipmentReference);
        }
        if (eventCreatedDateTime !== undefined && eventCreatedDateTime !== null) {
            queryParameters = queryParameters.set('eventCreatedDateTime', <any>eventCreatedDateTime);
        }
        if (eventDateTime !== undefined && eventDateTime !== null) {
            queryParameters = queryParameters.set('eventDateTime', <any>eventDateTime);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;
        if (aPIVersion !== undefined && aPIVersion !== null) {
            headers = headers.set('API-Version', String(aPIVersion));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ShipmentEvent>>('get',`${this.basePath}/v2/events/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
