/**
 * DCSA OpenAPI specification for Booking v2 - Beta 1
 * API specification issued by DCSA.org.  For explanation to specific values or objects please refer to the *** [Information Model v2022.1]() *** Will be updated soon ***. This API does not define the business rules regarding what is allowed to update at what time. For this the [BKG IFS]() *** Will be updated soon *** should be consulted.  All other documents related to the Booking publication can be found [here](https://knowledge.dcsa.org/s/publication?publicationId=a0r7T000000L8mmQAC)  It is possible to use this API as a standalone API. In order to do so it is necessary to use the poll-endPoint - /v2/events  in order to poll event information.  It is recomended to implement the [DCSA Documentation Event Hub](https://app.swaggerhub.com/apis/dcsaorg/DOCUMENTATION_EVENT_HUB) in order to use the push model. Here events are pushed as they occur.  For a changelog please click [here](https://github.com/dcsaorg/DCSA-OpenAPI/tree/master/bkg/v2#v200B1). Please also [create a GitHub issue](https://github.com/dcsaorg/DCSA-OpenAPI/issues/new) if you have any questions/comments. 
 *
 * The version of the OpenAPI document: 2.0.0-Beta-1
 * Contact: info@dcsa.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { BookingDocumentTypeCode } from '../model/bookingDocumentTypeCode';
// @ts-ignore
import { BookingShipmentEventTypeCode } from '../model/bookingShipmentEventTypeCode';
// @ts-ignore
import { ModelError } from '../model/modelError';
// @ts-ignore
import { ShipmentEvent } from '../model/shipmentEvent';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class BookingEventsService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get Shipment events
     * Retrieves &#x60;Booking&#x60; related &#x60;Shipment Events&#x60;.  If not specified - this list will be sorted by the time the &#x60;ShipmentEvent&#x60; was created (eventCreatedDateTime) in ascending (ASC) order. 
     * @param shipmentEventTypeCode The status of the document in the booking process to filter by. Possible values are - RECE (Received) - PENU (Pending Update) - PENC (Pending Confirmation) - CONF (Confirmed) - REJE (Rejected) - CANC (Cancelled) - CMPL (Completed)  It is possible to select multiple values by comma &#x60;,&#x60; separating them. For multiple values the OR-operator is used. For example _shipmentEventTypeCode&#x3D;RECE,CONF_  Matches **both** Received (&#x60;RECE&#x60;) and Confirmed (&#x60;CONF&#x60;) &#x60;ShipmentEvents&#x60;.  More details can be found on &lt;a href&#x3D;\&quot;https://github.com/dcsaorg/DCSA-Information-Model/blob/master/datamodel/referencedata.d/shipmenteventtypecodes.csv\&quot;&gt;GitHub&lt;/a&gt;. Be aware that the list provided here is a subset of the possible values. 
     * @param documentTypeCode The &#x60;documentTypeCode&#x60; to filter by. Possible values are - CBR (Carrier Booking Request Reference) - BKG (Booking)  It is possible to select multiple values by comma &#x60;,&#x60; separating them. For multiple values the OR-operator is used. For example _documentTypeCode&#x3D;CBR,BKG_ Matches **both** &#x60;ShipmentEvents&#x60; related to Booking Requests (&#x60;CBR&#x60;) and Confirmed Bookings (&#x60;BKG&#x60;).  More details can be found on &lt;a href&#x3D;\&quot;https://github.com/dcsaorg/DCSA-Information-Model/blob/master/datamodel/referencedata.d/documenttypecodes.csv\&quot;&gt;GitHub&lt;/a&gt;. Be aware that the list provided here is a subset of the possible values.         
     * @param documentReference Filter on the &#x60;documentReference&#x60;. The &#x60;documentReference&#x60; can refer to any document - to qualify the type &#x60;documentTypeCode&#x60; should also be specified. Please be aware that &#x60;documentReference&#x60; by itself is not unique and may match different \&#39;types\&#39; of documents  Specifying this filter will only return &#x60;ShipmentEvents&#x60; related to this particular &#x60;documentReference&#x60;. 
     * @param equipmentReference Will filter by the unique identifier for the equipment, which should follow the BIC ISO Container Identification Number where possible.  Specifying this filter will only return events related to this particular &#x60;equipmentReference&#x60; 
     * @param eventCreatedDateTime Limit the result based on the creating date of the event. It is possible to use operators on this query parameter. This is done by adding a colon (&#x60;:&#x60;) followed by an operator at the end of the queryParameterName (before the equal (&#x60;&#x3D;&#x60;))      eventCreatedDateTime:gte&#x3D;2021-04-01T14:12:56+01:00  would result in all events created &amp;#8805; 2021-04-01T14&amp;#58;12&amp;#58;56+01&amp;#58;00  The following operators are supported - &#x60;:gte&#x60; (&amp;#8805; Greater than or equal) - &#x60;:gt&#x60; (&amp;#62; Greater than) - &#x60;:lte&#x60; (&amp;#8804; Less than or equal) - &#x60;:lt&#x60; (&amp;#60; Less than) - &#x60;:eq&#x60; (&amp;#61; Equal to)  If no operator is provided, a **strictly equal** is used (this is equivalent to &#x60;:eq&#x60; operator). 
     * @param eventDateTime Limit the result based on when the event will happen or has happened. It is possible to use operators on this query parameter. This is done by adding a colon (&#x60;:&#x60;) followed by an operator at the end of the queryParameterName (before the equal (&#x60;&#x3D;&#x60;))      eventDateTime:gte&#x3D;2021-04-01T14:12:56+01:00  would result in all events happened and will happen &amp;#8805; 2021-04-01T14&amp;#58;12&amp;#58;56+01&amp;#58;00  The following operators are supported - &#x60;:gte&#x60; (&amp;#8805; Greater than or equal) - &#x60;:gt&#x60; (&amp;#62; Greater than) - &#x60;:lte&#x60; (&amp;#8804; Less than or equal) - &#x60;:lt&#x60; (&amp;#60; Less than) - &#x60;:eq&#x60; (&amp;#61; Equal to)  If no operator is provided, a **strictly equal** is used (this is equivalent to &#x60;:eq&#x60; operator). 
     * @param limit Maximum number of items to return. 
     * @param sort A &#x60;,&#x60; (comma) separated list of field names to define the sort order. Field names should be suffixed by a &#x60;:&#x60; (colon) followed by either the keyword &#x60;ASC&#x60; (for ascending order) or &#x60;DESC&#x60; (for descening order) to specify direction. &#x60;:ASC&#x60; may be omitted, in which case ascending order will be used. 
     * @param aPIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: string, equipmentReference?: string, eventCreatedDateTime?: string, eventDateTime?: string, limit?: number, sort?: string, aPIVersion?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<ShipmentEvent>>;
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: string, equipmentReference?: string, eventCreatedDateTime?: string, eventDateTime?: string, limit?: number, sort?: string, aPIVersion?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<ShipmentEvent>>>;
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: string, equipmentReference?: string, eventCreatedDateTime?: string, eventDateTime?: string, limit?: number, sort?: string, aPIVersion?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<ShipmentEvent>>>;
    public v2EventsGet(shipmentEventTypeCode?: Array<BookingShipmentEventTypeCode>, documentTypeCode?: Array<BookingDocumentTypeCode>, documentReference?: string, equipmentReference?: string, eventCreatedDateTime?: string, eventDateTime?: string, limit?: number, sort?: string, aPIVersion?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (shipmentEventTypeCode) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                [...shipmentEventTypeCode].join(COLLECTION_FORMATS['csv']), 'shipmentEventTypeCode');
        }
        if (documentTypeCode) {
            localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                [...documentTypeCode].join(COLLECTION_FORMATS['csv']), 'documentTypeCode');
        }
        if (documentReference !== undefined && documentReference !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>documentReference, 'documentReference');
        }
        if (equipmentReference !== undefined && equipmentReference !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>equipmentReference, 'equipmentReference');
        }
        if (eventCreatedDateTime !== undefined && eventCreatedDateTime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>eventCreatedDateTime, 'eventCreatedDateTime');
        }
        if (eventDateTime !== undefined && eventDateTime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>eventDateTime, 'eventDateTime');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (sort !== undefined && sort !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sort, 'sort');
        }

        let localVarHeaders = this.defaultHeaders;
        if (aPIVersion !== undefined && aPIVersion !== null) {
            localVarHeaders = localVarHeaders.set('API-Version', String(aPIVersion));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v2/events/`;
        return this.httpClient.request<Array<ShipmentEvent>>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
